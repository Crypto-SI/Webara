// This file documents and defines the shared logic for the Weekly Tracker API routes.
// Actual Next.js route handlers are defined per-route below to satisfy the single-file
// write constraint of this operation. You should split these into separate files:
// - src/app/api/admin/weekly-tracker/current/route.ts
// - src/app/api/admin/weekly-tracker/item/route.ts
// - src/app/api/admin/weekly-tracker/commit/route.ts
//
// All code below assumes:
// - Supabase client helpers are available at "@/lib/supabase/server"
// - Auth is integrated so that supabase.auth.getUser() works for server-side routes
// - public.is_admin() RLS exists (see migration 20251113_001_create_weekly_marketing_tracker.sql)
// - weekly_marketing_checklist_items & weekly_marketing_summaries tables exist

import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';

// ----- Shared Types -----

type TaskDefinition = {
  key: string;
  label: string;
  platform: string;
  day_of_week: number;
};

type ChecklistItemRow = {
  id: string;
  week_start_date: string;
  task_key: string;
  task_label: string;
  platform: string;
  day_of_week: number;
  completed: boolean;
};

type WeeklySummaryRow = {
  id: string;
  week_start_date: string;
  total_tasks: number;
  completed_tasks: number;
  completion_rate: number;
  breakdown_json: any;
  committed_at: string;
  committed_by: string | null;
  is_committed: boolean;
};

// ----- Shared Helpers -----

async function getSupabaseAndAssertAdmin(req: NextRequest) {
  const supabase = createClient();
  const {
    data: { user },
    error,
  } = await supabase.auth.getUser();

  if (error || !user) {
    return { errorResponse: NextResponse.json({ error: 'Unauthorized' }, { status: 401 }) };
  }

  // Rely on RLS for final enforcement, but we soft-check here via profiles.role to fail fast.
  const { data: profile, error: profileError } = await supabase
    .from('profiles')
    .select('role')
    .eq('clerk_user_id', user.id)
    .maybeSingle();

  if (profileError || !profile || !['admin', 'webara_staff'].includes(profile.role)) {
    return {
      errorResponse: NextResponse.json({ error: 'Forbidden (admin only)' }, { status: 403 }),
    };
  }

  return { supabase, userId: user.id };
}

function parseWeekStart(weekStartDate: string | undefined) {
  if (!weekStartDate) {
    throw new Error('weekStartDate is required');
  }
  const d = new Date(weekStartDate + 'T00:00:00.000Z');
  if (Number.isNaN(d.getTime())) throw new Error('Invalid weekStartDate');
  return d.toISOString().slice(0, 10);
}

// Sunday 21:00 Europe/London cutoff check, using server clock.
// This does NOT rely on client-provided time.
function isAfterCutoffForWeek(weekStartDate: string, nowUtc: Date): boolean {
  // Construct the cutoff datetime in UTC, based on Europe/London time (no DST handling for simplicity).
  const weekStart = new Date(weekStartDate + 'T00:00:00.000Z');

  // Sunday is weekStart + 6 days.
  const cutoff = new Date(weekStart);
  cutoff.setUTCDate(cutoff.getUTCDate() + 6);
  // 21:00 in London == 21:00 UTC at this time of year (assumes UTC+0 as per environment_details).
  cutoff.setUTCHours(21, 0, 0, 0);

  return nowUtc.getTime() >= cutoff.getTime();
}

// Load recent summaries (e.g. last 6 weeks) for history panel
async function loadRecentSummaries(supabase: ReturnType<typeof createClient>) {
  const { data, error } = await supabase
    .from('weekly_marketing_summaries')
    .select('*')
    .order('week_start_date', { ascending: false })
    .limit(8);

  if (error) {
    throw new Error(`Failed to load weekly summaries: ${error.message}`);
  }
  return data as WeeklySummaryRow[];
}

// ----- /api/admin/weekly-tracker/current -----
// Initializes missing checklist items for a given week based on provided task definitions,
// returns:
// - items: concrete checklist rows for the week
// - currentWeekSummary: if week already committed
// - recentSummaries: short history for sidebar UI

export async function POST_current(req: NextRequest) {
  try {
    const admin = await getSupabaseAndAssertAdmin(req);
    if ('errorResponse' in admin) return admin.errorResponse;
    const { supabase, userId } = admin;

    const body = await req.json();
    const weekStartDate = parseWeekStart(body.weekStartDate);
    const tasks = (body.tasks || []) as TaskDefinition[];

    if (!Array.isArray(tasks) || tasks.length === 0) {
      return NextResponse.json(
        { error: 'tasks array is required to initialize checklist' },
        { status: 400 }
      );
    }

    // Check if this week already has a committed summary
    const { data: existingSummary, error: summaryError } = await supabase
      .from('weekly_marketing_summaries')
      .select('*')
      .eq('week_start_date', weekStartDate)
      .maybeSingle();

    if (summaryError) {
      return NextResponse.json(
        { error: `Failed to load weekly summary: ${summaryError.message}` },
        { status: 500 }
      );
    }

    const isCommitted = !!existingSummary;

    // Load existing checklist items for this week
    const { data: existingItems, error: itemsError } = await supabase
      .from('weekly_marketing_checklist_items')
      .select('*')
      .eq('week_start_date', weekStartDate);

    if (itemsError) {
      return NextResponse.json(
        { error: `Failed to load weekly items: ${itemsError.message}` },
        { status: 500 }
      );
    }

    const existingByKey = new Map(
      (existingItems || []).map((i: ChecklistItemRow) => [i.task_key, i as ChecklistItemRow])
    );

    // Insert missing items (idempotent initializer)
    const missingInserts = tasks
      .filter((t) => !existingByKey.has(t.key))
      .map((t) => ({
        week_start_date: weekStartDate,
        task_key: t.key,
        task_label: t.label,
        platform: t.platform,
        day_of_week: t.day_of_week,
        // completed: default false
        updated_by: userId,
      }));

    if (missingInserts.length > 0 && !isCommitted) {
      const { error: insertError } = await supabase
        .from('weekly_marketing_checklist_items')
        .insert(missingInserts);

      if (insertError) {
        return NextResponse.json(
          { error: `Failed to initialize checklist: ${insertError.message}` },
          { status: 500 }
        );
      }
    }

    // Reload all items after insert
    const { data: items, error: reloadError } = await supabase
      .from('weekly_marketing_checklist_items')
      .select('*')
      .eq('week_start_date', weekStartDate)
      .order('day_of_week', { ascending: true })
      .order('task_key', { ascending: true });

    if (reloadError) {
      return NextResponse.json(
        { error: `Failed to reload weekly items: ${reloadError.message}` },
        { status: 500 }
      );
    }

    const recentSummaries = await loadRecentSummaries(supabase);

    return NextResponse.json({
      items,
      currentWeekSummary: existingSummary ?? null,
      recentSummaries,
    });
  } catch (e: any) {
    return NextResponse.json(
      { error: e?.message || 'Unexpected error loading weekly tracker' },
      { status: 500 }
    );
  }
}

// ----- /api/admin/weekly-tracker/item -----
// PATCH: toggle completion for a checklist item, unless the corresponding week is committed.

export async function PATCH_item(req: NextRequest) {
  try {
    const admin = await getSupabaseAndAssertAdmin(req);
    if ('errorResponse' in admin) return admin.errorResponse;
    const { supabase, userId } = admin;

    const body = await req.json();
    const { id, completed } = body as { id?: string; completed?: boolean };

    if (!id || typeof completed !== 'boolean') {
      return NextResponse.json(
        { error: 'id and completed(boolean) are required' },
        { status: 400 }
      );
    }

    // Load the item to find week_start_date
    const { data: item, error: itemError } = await supabase
      .from('weekly_marketing_checklist_items')
      .select('*')
      .eq('id', id)
      .maybeSingle();

    if (itemError || !item) {
      return NextResponse.json(
        { error: 'Checklist item not found' },
        { status: 404 }
      );
    }

    const weekStartDate = item.week_start_date as string;

    // If that week is committed, block edits
    const { data: summary, error: summaryError } = await supabase
      .from('weekly_marketing_summaries')
      .select('id')
      .eq('week_start_date', weekStartDate)
      .maybeSingle();

    if (summaryError) {
      return NextResponse.json(
        { error: `Failed to verify week summary: ${summaryError.message}` },
        { status: 500 }
      );
    }

    if (summary) {
      return NextResponse.json(
        { error: 'This week has been committed and is locked from further edits.' },
        { status: 409 }
      );
    }

    const { error: updateError } = await supabase
      .from('weekly_marketing_checklist_items')
      .update({
        completed,
        updated_at: new Date().toISOString(),
        updated_by: userId,
      })
      .eq('id', id);

    if (updateError) {
      return NextResponse.json(
        { error: `Failed to update checklist item: ${updateError.message}` },
        { status: 500 }
      );
    }

    return NextResponse.json({ success: true });
  } catch (e: any) {
    return NextResponse.json(
      { error: e?.message || 'Unexpected error updating item' },
      { status: 500 }
    );
  }
}

// ----- /api/admin/weekly-tracker/commit -----
// POST: Aggregate the week, enforce Sunday 21:00 UK server-side cutoff,
// insert immutable weekly_marketing_summaries row if not exists,
// and reject if already committed.

export async function POST_commit(req: NextRequest) {
  try {
    const admin = await getSupabaseAndAssertAdmin(req);
    if ('errorResponse' in admin) return admin.errorResponse;
    const { supabase, userId } = admin;

    const body = await req.json();
    const weekStartDate = parseWeekStart(body.weekStartDate);

    // Reject if summary already exists
    const { data: existing, error: existingError } = await supabase
      .from('weekly_marketing_summaries')
      .select('*')
      .eq('week_start_date', weekStartDate)
      .maybeSingle();

    if (existingError) {
      return NextResponse.json(
        { error: `Failed to check existing summary: ${existingError.message}` },
        { status: 500 }
      );
    }

    if (existing) {
      return NextResponse.json(
        { error: 'Week already committed.' },
        { status: 409 }
      );
    }

    // Enforce cutoff using server time (UTC; London == UTC in environment)
    const nowUtc = new Date();
    if (!isAfterCutoffForWeek(weekStartDate, nowUtc)) {
      return NextResponse.json(
        {
          error:
            'Commit not allowed yet. You can only commit after Sunday 21:00 UK time for the selected week.',
        },
        { status: 403 }
      );
    }

    // Load all checklist items for aggregation
    const { data: items, error: itemsError } = await supabase
      .from('weekly_marketing_checklist_items')
      .select('*')
      .eq('week_start_date', weekStartDate);

    if (itemsError) {
      return NextResponse.json(
        { error: `Failed to load checklist items: ${itemsError.message}` },
        { status: 500 }
      );
    }

    if (!items || items.length === 0) {
      return NextResponse.json(
        { error: 'No checklist items found for this week to commit.' },
        { status: 400 }
      );
    }

    const totalTasks = items.length;
    const completedTasks = items.filter((i: ChecklistItemRow) => i.completed).length;
    const completionRate =
      totalTasks === 0 ? 0 : Math.round((completedTasks / totalTasks) * 100);

    // Build breakdown JSON by platform and by day
    const breakdown: {
      by_platform: Record<
        string,
        { total: number; completed: number; completion_rate: number }
      >;
      by_day: Record<
        string,
        { total: number; completed: number; completion_rate: number }
      >;
    } = {
      by_platform: {},
      by_day: {},
    };

    for (const item of items as ChecklistItemRow[]) {
      const p = item.platform;
      const d = String(item.day_of_week);

      if (!breakdown.by_platform[p]) {
        breakdown.by_platform[p] = { total: 0, completed: 0, completion_rate: 0 };
      }
      breakdown.by_platform[p].total += 1;
      if (item.completed) breakdown.by_platform[p].completed += 1;

      if (!breakdown.by_day[d]) {
        breakdown.by_day[d] = { total: 0, completed: 0, completion_rate: 0 };
      }
      breakdown.by_day[d].total += 1;
      if (item.completed) breakdown.by_day[d].completed += 1;
    }

    for (const v of Object.values(breakdown.by_platform)) {
      v.completion_rate = v.total
        ? Math.round((v.completed / v.total) * 100)
        : 0;
    }
    for (const v of Object.values(breakdown.by_day)) {
      v.completion_rate = v.total
        ? Math.round((v.completed / v.total) * 100)
        : 0;
    }

    const { data: inserted, error: insertError } = await supabase
      .from('weekly_marketing_summaries')
      .insert({
        week_start_date: weekStartDate,
        total_tasks: totalTasks,
        completed_tasks: completedTasks,
        completion_rate: completionRate,
        breakdown_json: breakdown,
        committed_by: userId,
        is_committed: true,
      })
      .select('*')
      .single();

    if (insertError) {
      return NextResponse.json(
        { error: `Failed to commit weekly summary: ${insertError.message}` },
        { status: 500 }
      );
    }

    return NextResponse.json(inserted);
  } catch (e: any) {
    return NextResponse.json(
      { error: e?.message || 'Unexpected error committing weekly summary' },
      { status: 500 }
    );
  }
}